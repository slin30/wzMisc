% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count_sigfigs.R
\name{count_sigfigs}
\alias{count_sigfigs}
\title{Count number significant figures}
\usage{
count_sigfigs(x, digits = getOption("digits"), countTrailing = FALSE)
}
\arguments{
\item{x}{numeric or character vector; only character input is allowed if \code{countTrailing=TRUE}.}

\item{digits}{integer of length 1. Optional. Default uses value from \code{getOptions("digits")}. Will
warn if this is set higher than 15, for good reason. See notes.}

\item{countTrailing}{logical. Should trailing zeros be counted? Defaults to \code{FALSE}.}
}
\value{
An integer vector of significant digit counts equal in length to input vector.
}
\description{
Count number of significant digits (figures), option to include trailing zeros
}
\details{
Count number of significant digits, either from a (measurement) precision or a (mathematical) numeric
perspective via the \emph{countTrailing} option. When set to \code{TRUE} and provided a \code{character} input
\emph{x}, this option will count trailing zeros as significant digits. Leading zeros are (almost) never counted; the
single exception is when \code{countTrailing=TRUE} and \emph{x} contains values that would be coerced to \code{0}
via e.g. \code{as.integer} or \code{as.numeric}; see Notes.

By default, \code{countTrailing=FALSE}; this counts significant digits from a (mathematical) numeric perspective.
Setting to \code{TRUE} counts significant digits from a (measurement) precision perspective.

Because \emph{R} (and most other analysis tools/languages) will automatically strip trailing zeros for
 \code{integer} or \code{numeric} data types, this function will throw an error if \code{countTrailing=TRUE} and
 \code{class(x) != "character"}.

This function does not perform any explicit rounding or truncation of input within reasonable limits;
if input precision exceeds system limit, standard R rounding rules will apply, silently.
}
\note{
Zero is a special case. If \code{countTrailing=FALSE}, will return zero. If \code{countTrailing=TRUE}, all
digits are counted, excluding digits following the exponent notation (\code{e} or \code{E}) if applicable. See examples

This function assumes that if you provide character inputs that would evaluate to \code{0} if treated as a number, this is
in fact meaningful from a precision/measurement perspective.
}
\examples{
set.seed(1)
x <- mapply(signif, rnorm(10), 1:10)
count_sigfigs(x)
count_sigfigs(x, digits = 10)

#Also works for scientific notation
count_sigfigs(c(1E10, -1E10, -000001E-10)) #all 1
count_sigfigs(c("1.0001", 1.0001, 0001.0001)) #all 5

#digits option
#By default, will use local number of digits, which is 7
getOption("digits") #default should be 7
count_sigfigs(0.1234567) #7
count_sigfigs(0.12345678) #8
count_sigfigs(0.123456789) #8
count_sigfigs(0.123456789, digits = 8) #9

#countTrailing
count_sigfigs("1.0100", countTrailing = TRUE)
count_sigfigs("1.0100E10", countTrailing = TRUE)

#zero handling
zeros_decimal  <- c("0", "0.0", "00.0", "00.00", "0.000")
zeros_exponent <- c("0E0", "0.0E0", "00.0E0", "00.00E0", "0.000E0")
count_sigfigs(zeros_decimal) #all zero
count_sigfigs(zeros_decimal, countTrailing = TRUE) #1,2,3,4,4
count_sigfigs(zeros_exponent) #all zero
count_sigfigs(zeros_exponent, countTrailing = TRUE) #also 1,2,3,4,4

\dontrun{
#compare:
count_sigfigs(123.12345679, digits = 7)  #need higher digits option
count_sigfigs(123.12345679, digits = 15) #what you expected
count_sigfigs(123.12345679, digits = 16) #probably not what you expected

#also
count_sigfigs(1000000001.12345, digits = 15) #pushing it
}
}
