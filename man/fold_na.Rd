% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fold_na.R
\name{fold_na}
\alias{fold_na}
\title{Return the first non-missing value from two or more atomic vectors}
\usage{
fold_na(...)
}
\arguments{
\item{...}{Atomic vectors or a \code{list} containing atomic vectors of the same type and length.
Inputs of length \code{1} are allowed and potentially recycled to the length of the longest input,
but this behavior varies depending on the input order. See details.}
}
\value{
An atomic vector of the same type as the inputs (although any class attributes will be stripped). The
length will be either \code{1} if the first supplied input is a non-missing atomic vector of length 1
or the length of the inputs -- assuming input lengths are otherwise equivalent (but greater than 1).
}
\description{
Given two or more atomic vectors, fold each vector element-wise left-to-right, carrying forward
the first non-missing value
}
\details{
This is very similar to SQL's \code{coalesce} function, but is intentionally named to avoid clashing
with the \code{dplyr} implementation. This is strictly written in base \code{R} and follows the same
class-handling rules as implemented by \link[base]{ifelse}.

The function will exit when it detects that no additional \code{NA} values are present or when all
inputs have been evaluated, whichever comes first. If you supply e.g. a non-missing vector of length 1
as the first input, then the function will only ever return that supplied value because the one of the
two aforementioned conditions will have been satisfied. See examples
}
\note{
The non-exported helper function \code{.fold_na_base()} has slightly different behavior when handling
vectors of length 1 combined with vectors of length > 1, regardless of argument order. The helper
ensures outputs are always the length of the longest input(s). If this is desireable, then you can
effectively achieve the same result by calling the helper along with e.g. \link[base]{Reduce}. If so, make
sure you pass the inputs as a (flat) \code{list}.
}
\examples{
x <- 1:10L
y <- c(1L, NA, 3L, NA, 5L, NA, 7L, NA, 9L, NA)
z <- c(NA, 2L, NA, 4L, NA, 6L, NA, 8L, NA, 10L)

fold_na(x) # returns x

fold_na(y, z) # regnerates x
fold_na(list(y, z)) # same

# works the same on data.frames
df <- data.frame(y, z, x)
fold_na(df)
fold_na(df[, c("y", "z")])

# These are not equivalent
fold_na(y, 0L) # NA in y substituted with 0
fold_na(0L, y) # only returns zero as vector of length 1!
}
